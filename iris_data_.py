# -*- coding: utf-8 -*-
"""IRIS data .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XRteT9ZXpXHj3bbEZ9eVe2WngXLsuXYq
"""

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

#for data visualization
import seaborn as sns
import matplotlib.pyplot as plt
import plotly.express as px

from scipy import stats

"""Loading the data"""

#load the dataset

iris = pd.read_csv("/content/IRIS.csv") #load the dataset
print(iris)

iris.info()

iris.describe

# get the column names
columns = list(iris)
iris.columns

# find dimensions of the dataset
iris.shape  #150 rows and 5 columns

print(iris["species"].value_counts())

iris.info(memory_usage='deep') #No missing values found.

iris.describe()

"""2 Data inspection : Visualization






2 Data inspection : Visualization¶
When dealing with a set of data, often the first thing you’ll want to do is get a sense for how the variables are distributed. Visualization helps us to identify and analyse the distributions more easily and effectively.

2.1 Plotting Univariate distributions
2.1.1 Distplot
The most convenient way to take a quick look at a univariate distribution in seaborn is the distplot() function. By default, this will draw a histogram and fit a kernel density estimate (KDE).

A histogram helps you discover, and show, the underlying frequency distribution (shape) of a set of continuous data.A KDE , on the other hand,is a fundamental data smoothing problem and provides a smooth curve to show the shape of the data under observation.
```
# This is formatted as code
```


"""

ds=pd.DataFrame(iris)
ds

fig, ax =plt.subplots(1,4,figsize=(20,6))


sns.distplot(iris.sepal_length,ax=ax[0])
sns.distplot(iris.sepal_width,ax=ax[1])
sns.distplot(iris.petal_length,ax=ax[2])
sns.distplot(iris.petal_width,ax=ax[3])

fig.show()

sns.distplot(ds.sepal_length, kde=True, fit=stats.norm);

"""2.1.2 Boxplot¶



A boxplot is a standardized way of displaying the distribution of data based on a five number summary (“minimum”, first quartile (Q1), median, third quartile (Q3), and “maximum”). It helps us to identify the outliers and what their values are. It can also tell whether the data is symmetrical, how tightly your data is grouped, and if and how your data is skewed.
"""

sns.boxplot(x="species", y="sepal_length", data=iris)

"""2.1.3 Violin Plot¶



Violin Plot is a method to visualize the distribution of numerical data of different variables. It is similar to Box Plot but with a rotated plot on each side, giving more information about the density estimate on the y-axis.The advantage of a violin plot is that it can show nuances in the distribution that aren’t noticeable in a boxplot. On the other hand, the boxplot more clearly shows the outliers in the data.
"""

sns.violinplot(x="species",y="sepal_length",data = iris)
plt.title("Violin plot for sepal_ength and Species")
plt.show()

"""2.1.4 Swarm plot¶



A categorical scatterplot with non-overlapping points. It is a good complement to a box or violin plot in cases where you want to show all observations along with some representation of the underlying distribution.
"""

ax = sns.swarmplot(x="sepal_length", y="species", data=iris)

"""2.2 Building structured multi-plot grids using FacetGrid class
The FacetGrid class is useful to visualize the distribution of a variable or the relationship between multiple variables separately within subsets of your dataset. A FacetGrid can be drawn with up to three dimensions: row, col, and hue.
"""

g = sns.FacetGrid(iris, col="species")
g.map(plt.hist, "sepal_length");



"""2.3 Plotting bivariate distributions¶

2.3.1 scatterplots

The most familiar way to visualize a bivariate distribution is a scatterplot, where each observation is shown with point at the x and y values.

2.3.2 Hexbin plot



The bivariate analogue of a histogram is known as a “hexbin” plot, because it shows the counts of observations that fall within hexagonal bins. This plot works best with relatively large dataset.
"""

with sns.axes_style("white"):
    sns.jointplot(x="sepal_length", y="sepal_width", kind="hex", color="k",data=iris);

dataset = px.data.iris()
x = dataset.iloc[:, :4].values
dataset

dataset = px.data.iris()
x = dataset.iloc[:, :3].values
dataset

x

#Finding the optimum number of clusters for k-means classification
from sklearn.cluster import KMeans
wcss = []

for i in range(1, 11):
    kmeans = KMeans(n_clusters = i, init = 'k-means++', max_iter = 300, n_init = 10, random_state = 0)
    kmeans.fit(x)
    wcss.append(kmeans.inertia_)

#Plotting the results onto a line graph, allowing us to observe 'The elbow'
plt.plot(range(1, 11), wcss)
plt.title('The elbow method')
plt.xlabel('Number of clusters')
plt.ylabel('WCSS') #within cluster sum of squares
plt.show()

#Applying kmeans to the dataset / Creating the kmeans classifier
kmeans = KMeans(n_clusters = 3, init = 'k-means++', max_iter = 300, n_init = 10, random_state = 0)
y_kmeans = kmeans.fit_predict(x)

x[0,:]

k1 = dataset.iloc[:,:].values
k1

dataset.loc[y_kmeans == 0,'kmeans'] = 0

dataset2 = dataset
dataset2

dataset['k_means'] = y_kmeans

dataset

dataset2['kmeans'] = 0

dataset3 = dataset2.loc[y_kmeans == 0]['kmeans'] = 0

dataset3

y_kmeans

print(dataset.loc[y_kmeans == 0])

k1[y_kmeans == 0, :]

x[y_kmeans == 0, :]

x[y_kmeans == 0, 1]

import plotly.express as px
import pandas as pd

df = px.data.iris()

df['k_means'] = y_kmeans

df['k_means'] = y_kmeans
fig = px.treemap(df, path=['k_means','species','sepal_length'], values='species_id')
fig.show()

fig = px.treemap(df, path=['k_means','species','sepal_width'], values='species_id')
fig.show()

fig = px.treemap(df, path=['k_means','species','petal_length'], values='species_id')
fig.show()

fig = px.treemap(df, path=['k_means','species','petal_width'], values='species_id')
fig.show()

fig = px.treemap(df, path=['k_means','species','species_id','sepal_length'], values='species_id', color='species_id')
fig.show()

fig = px.treemap(dataset.loc[y_kmeans == 0], path=['species','species_id','sepal_length'], values=x[y_kmeans == 0, 0], color='species_id')
fig.show()

fig = px.treemap(dataset.loc[y_kmeans == 2], path=['species','species_id','sepal_width'], values=x[y_kmeans == 2,1], color='species_id')
fig.show()

fig = px.treemap(dataset.loc[y_kmeans == 0], path=['species','species_id','petal_length'], values=x[y_kmeans == 0,2], color='species_id')
fig.show()

